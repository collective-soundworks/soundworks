<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>server/ServerStateManager.js - soundworks</title>
    
    <meta name="description" content="Documentation of soundworks, a full-stack JavaScript framework for distributed WebAudio and multimedia applications" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="http://soundworks.dev/" target="_blank" class="menu-item" >Website</a></h2><h2><a href="https://github.com/collective-soundworks/soundworks" target="_blank" class="menu-item" >Github</a></h2><h3>Classes</h3><ul><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#getAuditState">getAuditState</a></li><li data-type='method'><a href="Client.html#init">init</a></li><li data-type='method'><a href="Client.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="Client.html#start">start</a></li><li data-type='method'><a href="Client.html#stop">stop</a></li></ul></li><li><a href="ClientContext.html">ClientContext</a><ul class='methods'><li data-type='method'><a href="ClientContext.html#enter">enter</a></li><li data-type='method'><a href="ClientContext.html#exit">exit</a></li><li data-type='method'><a href="ClientContext.html#start">start</a></li><li data-type='method'><a href="ClientContext.html#stop">stop</a></li></ul></li><li><a href="ClientContextManager.html">ClientContextManager</a><ul class='methods'><li data-type='method'><a href="ClientContextManager.html#get">get</a></li></ul></li><li><a href="ClientPluginManager.html">ClientPluginManager</a><ul class='methods'><li data-type='method'><a href="ClientPluginManager.html#addDependency">addDependency</a></li><li data-type='method'><a href="ClientPluginManager.html#get">get</a></li><li data-type='method'><a href="ClientPluginManager.html#getRegisteredPlugins">getRegisteredPlugins</a></li><li data-type='method'><a href="ClientPluginManager.html#getUnsafe">getUnsafe</a></li><li data-type='method'><a href="ClientPluginManager.html#onStateChange">onStateChange</a></li><li data-type='method'><a href="ClientPluginManager.html#register">register</a></li></ul></li><li><a href="ClientSocket.html">ClientSocket</a><ul class='methods'><li data-type='method'><a href="ClientSocket.html#addListener">addListener</a></li><li data-type='method'><a href="ClientSocket.html#removeAllListeners">removeAllListeners</a></li><li data-type='method'><a href="ClientSocket.html#removeListener">removeListener</a></li><li data-type='method'><a href="ClientSocket.html#send">send</a></li></ul></li><li><a href="ClientStateManager.html">ClientStateManager</a><ul class='methods'><li data-type='method'><a href="ClientStateManager.html#attach">attach</a></li><li data-type='method'><a href="ClientStateManager.html#create">create</a></li><li data-type='method'><a href="ClientStateManager.html#getClassDescription">getClassDescription</a></li><li data-type='method'><a href="ClientStateManager.html#getCollection">getCollection</a></li><li data-type='method'><a href="ClientStateManager.html#getSchema">getSchema</a></li><li data-type='method'><a href="ClientStateManager.html#observe">observe</a></li></ul></li><li><a href="Server.html">Server</a><ul class='methods'><li data-type='method'><a href="Server.html#generateAuthToken">generateAuthToken</a></li><li data-type='method'><a href="Server.html#getAuditState">getAuditState</a></li><li data-type='method'><a href="Server.html#init">init</a></li><li data-type='method'><a href="Server.html#isTrustedClient">isTrustedClient</a></li><li data-type='method'><a href="Server.html#isTrustedToken">isTrustedToken</a></li><li data-type='method'><a href="Server.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="Server.html#start">start</a></li><li data-type='method'><a href="Server.html#stop">stop</a></li><li data-type='method'><a href="Server.html#useDefaultApplicationTemplate">useDefaultApplicationTemplate</a></li></ul></li><li><a href="ServerClient.html">ServerClient</a></li><li><a href="ServerContext.html">ServerContext</a><ul class='methods'><li data-type='method'><a href="ServerContext.html#enter">enter</a></li><li data-type='method'><a href="ServerContext.html#exit">exit</a></li><li data-type='method'><a href="ServerContext.html#start">start</a></li><li data-type='method'><a href="ServerContext.html#stop">stop</a></li></ul></li><li><a href="ServerContextManager.html">ServerContextManager</a><ul class='methods'><li data-type='method'><a href="ServerContextManager.html#get">get</a></li></ul></li><li><a href="ServerPluginManager.html">ServerPluginManager</a><ul class='methods'><li data-type='method'><a href="ServerPluginManager.html#addDependency">addDependency</a></li><li data-type='method'><a href="ServerPluginManager.html#get">get</a></li><li data-type='method'><a href="ServerPluginManager.html#getRegisteredPlugins">getRegisteredPlugins</a></li><li data-type='method'><a href="ServerPluginManager.html#getUnsafe">getUnsafe</a></li><li data-type='method'><a href="ServerPluginManager.html#onStateChange">onStateChange</a></li><li data-type='method'><a href="ServerPluginManager.html#register">register</a></li></ul></li><li><a href="ServerSocket.html">ServerSocket</a><ul class='methods'><li data-type='method'><a href="ServerSocket.html#addListener">addListener</a></li><li data-type='method'><a href="ServerSocket.html#removeAllListeners">removeAllListeners</a></li><li data-type='method'><a href="ServerSocket.html#removeListener">removeListener</a></li><li data-type='method'><a href="ServerSocket.html#send">send</a></li></ul></li><li><a href="ServerSockets.html">ServerSockets</a></li><li><a href="ServerStateManager.html">ServerStateManager</a><ul class='methods'><li data-type='method'><a href="ServerStateManager.html#attach">attach</a></li><li data-type='method'><a href="ServerStateManager.html#create">create</a></li><li data-type='method'><a href="ServerStateManager.html#defineClass">defineClass</a></li><li data-type='method'><a href="ServerStateManager.html#deleteClass">deleteClass</a></li><li data-type='method'><a href="ServerStateManager.html#deleteSchema">deleteSchema</a></li><li data-type='method'><a href="ServerStateManager.html#getClassDescription">getClassDescription</a></li><li data-type='method'><a href="ServerStateManager.html#getCollection">getCollection</a></li><li data-type='method'><a href="ServerStateManager.html#getSchema">getSchema</a></li><li data-type='method'><a href="ServerStateManager.html#observe">observe</a></li><li data-type='method'><a href="ServerStateManager.html#registerCreateHook">registerCreateHook</a></li><li data-type='method'><a href="ServerStateManager.html#registerDeleteHook">registerDeleteHook</a></li><li data-type='method'><a href="ServerStateManager.html#registerSchema">registerSchema</a></li><li data-type='method'><a href="ServerStateManager.html#registerUpdateHook">registerUpdateHook</a></li></ul></li><li><a href="SharedState.html">SharedState</a><ul class='methods'><li data-type='method'><a href="SharedState.html#delete">delete</a></li><li data-type='method'><a href="SharedState.html#detach">detach</a></li><li data-type='method'><a href="SharedState.html#get">get</a></li><li data-type='method'><a href="SharedState.html#getDefaults">getDefaults</a></li><li data-type='method'><a href="SharedState.html#getDescription">getDescription</a></li><li data-type='method'><a href="SharedState.html#getInitValues">getInitValues</a></li><li data-type='method'><a href="SharedState.html#getSchema">getSchema</a></li><li data-type='method'><a href="SharedState.html#getUnsafe">getUnsafe</a></li><li data-type='method'><a href="SharedState.html#getValues">getValues</a></li><li data-type='method'><a href="SharedState.html#getValuesUnsafe">getValuesUnsafe</a></li><li data-type='method'><a href="SharedState.html#onDelete">onDelete</a></li><li data-type='method'><a href="SharedState.html#onDetach">onDetach</a></li><li data-type='method'><a href="SharedState.html#onUpdate">onUpdate</a></li><li data-type='method'><a href="SharedState.html#set">set</a></li></ul></li><li><a href="SharedStateCollection.html">SharedStateCollection</a><ul class='methods'><li data-type='method'><a href="SharedStateCollection.html#detach">detach</a></li><li data-type='method'><a href="SharedStateCollection.html#filter">filter</a></li><li data-type='method'><a href="SharedStateCollection.html#find">find</a></li><li data-type='method'><a href="SharedStateCollection.html#forEach">forEach</a></li><li data-type='method'><a href="SharedStateCollection.html#get">get</a></li><li data-type='method'><a href="SharedStateCollection.html#getDefaults">getDefaults</a></li><li data-type='method'><a href="SharedStateCollection.html#getDescription">getDescription</a></li><li data-type='method'><a href="SharedStateCollection.html#getSchema">getSchema</a></li><li data-type='method'><a href="SharedStateCollection.html#getUnsafe">getUnsafe</a></li><li data-type='method'><a href="SharedStateCollection.html#getValues">getValues</a></li><li data-type='method'><a href="SharedStateCollection.html#getValuesUnsafe">getValuesUnsafe</a></li><li data-type='method'><a href="SharedStateCollection.html#map">map</a></li><li data-type='method'><a href="SharedStateCollection.html#onAttach">onAttach</a></li><li data-type='method'><a href="SharedStateCollection.html#onChange">onChange</a></li><li data-type='method'><a href="SharedStateCollection.html#onDetach">onDetach</a></li><li data-type='method'><a href="SharedStateCollection.html#onUpdate">onUpdate</a></li><li data-type='method'><a href="SharedStateCollection.html#reduce">reduce</a></li><li data-type='method'><a href="SharedStateCollection.html#set">set</a></li><li data-type='method'><a href="SharedStateCollection.html#sort">sort</a></li></ul></li><li><a href="module.exports.html">module.exports</a><ul class='methods'><li data-type='method'><a href="module.exports.html#onStateChange">onStateChange</a></li><li data-type='method'><a href="module.exports.html#propagateStateChange">propagateStateChange</a></li><li data-type='method'><a href="module.exports.html#start">start</a></li><li data-type='method'><a href="module.exports.html#stop">stop</a></li></ul></li><li></li></ul><h3>Global</h3><ul><li><a href="global.html#ClientAppConfig">ClientAppConfig</a></li><li><a href="global.html#ClientConfig">ClientConfig</a></li><li><a href="global.html#ClientDescription">ClientDescription</a></li><li><a href="global.html#ClientEnvConfig">ClientEnvConfig</a></li><li><a href="global.html#ClientRole">ClientRole</a></li><li><a href="global.html#ServerAppConfig">ServerAppConfig</a></li><li><a href="global.html#ServerConfig">ServerConfig</a></li><li><a href="global.html#ServerEnvConfig">ServerEnvConfig</a></li><li><a href="global.html#SharedStateClassDescription">SharedStateClassDescription</a></li><li><a href="global.html#SharedStateClassName">SharedStateClassName</a></li><li><a href="global.html#SharedStateParameterDescription">SharedStateParameterDescription</a></li><li><a href="global.html#SharedStateParameterName">SharedStateParameterName</a></li><li><a href="global.html#addClient">addClient</a></li><li><a href="global.html#client">client</a></li><li><a href="global.html#clients">clients</a></li><li><a href="global.html#pluginDeleteOnStateChangeCallback">pluginDeleteOnStateChangeCallback</a></li><li><a href="global.html#pluginManagerDeleteOnStateChangeCallback">pluginManagerDeleteOnStateChangeCallback</a></li><li><a href="global.html#pluginManagerOnStateChangeCallback">pluginManagerOnStateChangeCallback</a></li><li><a href="global.html#pluginOnStateChangeCallback">pluginOnStateChangeCallback</a></li><li><a href="global.html#removeClient">removeClient</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#serverStateManagerCreateHook">serverStateManagerCreateHook</a></li><li><a href="global.html#serverStateManagerDeleteHook">serverStateManagerDeleteHook</a></li><li><a href="global.html#serverStateManagerUpdateHook">serverStateManagerUpdateHook</a></li><li><a href="global.html#sharedStateCollectionDeleteOnAttachCallback">sharedStateCollectionDeleteOnAttachCallback</a></li><li><a href="global.html#sharedStateCollectionDeleteOnChangeCallback">sharedStateCollectionDeleteOnChangeCallback</a></li><li><a href="global.html#sharedStateCollectionDeleteOnDetachCallback">sharedStateCollectionDeleteOnDetachCallback</a></li><li><a href="global.html#sharedStateCollectionDeleteOnUpdateCallback">sharedStateCollectionDeleteOnUpdateCallback</a></li><li><a href="global.html#sharedStateCollectionOnAttachCallback">sharedStateCollectionOnAttachCallback</a></li><li><a href="global.html#sharedStateCollectionOnChangeCallback">sharedStateCollectionOnChangeCallback</a></li><li><a href="global.html#sharedStateCollectionOnDetachCallback">sharedStateCollectionOnDetachCallback</a></li><li><a href="global.html#sharedStateCollectionOnUpdateCallback">sharedStateCollectionOnUpdateCallback</a></li><li><a href="global.html#sharedStateDeleteOnUpdateCallback">sharedStateDeleteOnUpdateCallback</a></li><li><a href="global.html#sharedStateOnUpdateCallback">sharedStateOnUpdateCallback</a></li><li><a href="global.html#stateManagerDeleteObserveCallback">stateManagerDeleteObserveCallback</a></li><li><a href="global.html#stateManagerObserveCallback">stateManagerObserveCallback</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">server/ServerStateManager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { counter, isString, isPlainObject, isFunction } from '@ircam/sc-utils';
import clonedeep from 'lodash/cloneDeep.js';

import BaseStateManager, {
  kStateManagerInit,
} from '../common/BaseStateManager.js';
import BatchedTransport from '../common/BatchedTransport.js';
import ParameterBag from '../common/ParameterBag.js';
import {
  CREATE_REQUEST,
  CREATE_RESPONSE,
  CREATE_ERROR,
  DELETE_NOTIFICATION,
  ATTACH_REQUEST,
  ATTACH_RESPONSE,
  ATTACH_ERROR,
  OBSERVE_REQUEST,
  OBSERVE_RESPONSE,
  OBSERVE_ERROR,
  OBSERVE_NOTIFICATION,
  UNOBSERVE_NOTIFICATION,
  DELETE_SHARED_STATE_CLASS,
  GET_CLASS_DESCRIPTION_REQUEST,
  GET_CLASS_DESCRIPTION_RESPONSE,
  GET_CLASS_DESCRIPTION_ERROR,
  PRIVATE_STATES,
} from '../common/constants.js';

import SharedStatePrivate, {
  kSharedStatePrivateAttachClient,
  kSharedStatePrivateDetachClient,
  kSharedStatePrivateGetValues,
} from './SharedStatePrivate.js';

import logger from '../common/logger.js';


const generateStateId = counter();
const instanceIdGenerator = counter();

export const kServerStateManagerAddClient = Symbol('soundworks:server-state-manager-add-client');
export const kServerStateManagerRemoveClient = Symbol('soundworks:server-state-manager-remove-client');
export const kServerStateManagerHasClient = Symbol('soundworks:server-state-manager-has-client');
export const kServerStateManagerDeletePrivateState = Symbol('soundworks:server-state-manager-delete-private-state');
export const kServerStateManagerGetUpdateHooks = Symbol('soundworks:server-state-manager-get-update-hooks');
// for testing purposes
export const kStateManagerClientsByNodeId = Symbol('soundworks:server-state-clients-by-node-id');


/**
 * @callback serverStateManagerCreateHook
 * @async
 *
 * @param {object} initValues - Initialization values object as given when the
 *  shared state is created
 */

/**
 * @callback serverStateManagerUpdateHook
 * @async
 *
 * @param {object} updates - Update object as given on a `set` callback, or
 *  result of the previous hook.
 * @param {object} currentValues - Current values of the state.
 * @returns {object} The "real" updates to be applied on the state.
 */

/**
 * @callback serverStateManagerDeleteHook
 * @async
 *
 * @param {object} currentValues - Update object as given on a `set` callback, or
 *  result of the previous hook.
 */

/**
 * The `StateManager` allows to create new {@link SharedState}s, or attach
 * to {@link SharedState}s created by other nodes (clients or server). It
 * can also track all the {@link SharedState}s created by other nodes.
 *
 * An instance of `StateManager` is automatically created by the `soundworks.Server`
 * at initialization (cf. {@link Server#stateManager}).
 *
 * Compared to the {@link ClientStateManager}, the `ServerStateManager` can also
 * define and delete shared state classes, as well as register hooks executed at
 * lifecycle phases of a shared state
 *
 * See {@link Server#stateManager}
 *
 * Tutorial: {@link https://soundworks.dev/guide/state-manager.html}
 *
 * ```
 * // server-side
 * import { Server } from '@soundworks/server/index.js';
 *
 * const server = new Server(config);
 * // declare and register the class of a shared state.
 * server.stateManager.defineClass('some-global-state', {
 *   myRandom: {
 *     type: 'float',
 *     default: 0,
 *   }
 * });
 *
 * await server.start();
 *
 * // create a global state server-side
 * const globalState = await server.stateManager.create('some-global-state');
 * // listen and react to the changes made by the clients
 * globalState.onUpdate(updates => console.log(updates));
 * ```
 *
 * ```
 * // client-side
 * import { Client } from '@soundworks/client.index.js';
 *
 * const client = new Client(config);
 * await client.start();
 *
 * // attach to the global state created by the server
 * const globalState = await client.stateManager.attach('some-global-state');
 *
 * // update the value of a `myRandom` parameter every seconds
 * setInterval(() => {
 *   globalState.set({ myRandom: Math.random() });
 * }, 1000);
 * ```
 *
 * @extends BaseStateManager
 * @inheritdoc
 * @hideconstructor
 */
class ServerStateManager extends BaseStateManager {
  #sharedStatePrivateById = new Map();
  #classes = new Map();
  #observers = new Set();
  #createHooksByClassName = new Map();
  #updateHooksByClassName = new Map();
  #deleteHooksByClassName = new Map();

  constructor() {
    super();
    /** @private */
    this[kStateManagerClientsByNodeId] = new Map();
  }

  /** @private */
  [kStateManagerInit](id, transport) {
    super[kStateManagerInit](id, transport);
    // add itself as client of the state manager server
    this[kServerStateManagerAddClient](id, transport);
  }

  /** @private */
  async [kServerStateManagerDeletePrivateState](state) {
    this.#sharedStatePrivateById.delete(state.id);
    // @todo - could use getValuesUnsafe instead
    let currentValues = state[kSharedStatePrivateGetValues]();
    const hooks = this.#deleteHooksByClassName.get(state.className);

    for (let hook of hooks.values()) {
      const result = await hook(currentValues);

      if (result === null) { // explicit abort
        break;
      } else if (result === undefined) { // implicit continue
        continue;
      } else {
        currentValues = result;
      }
    }
  }

  /** @private */
  [kServerStateManagerGetUpdateHooks](className) {
    return this.#updateHooksByClassName.get(className);
  }

  /** @private */
  [kServerStateManagerHasClient](nodeId) {
    return this[kStateManagerClientsByNodeId].has(nodeId);
  }

  /**
   * Add a client to the manager.
   *
   * This is automatically handled by the {@link Server} when a client connects.
   *
   * @param {number} nodeId - Unique id of the client node
   * @param {object} transport - Transport mechanism to communicate with the
   *  client. Must implement a basic EventEmitter API.
   *
   * @private
   */
  [kServerStateManagerAddClient](nodeId, transport) {
    const batchedTransport = new BatchedTransport(transport);
    const client = {
      id: nodeId,
      transport: batchedTransport,
    };

    this[kStateManagerClientsByNodeId].set(nodeId, client);

    // ---------------------------------------------
    // CREATE
    // ---------------------------------------------
    client.transport.addListener(
      CREATE_REQUEST,
      async (reqId, className, requireDescription, initValues = {}) => {
        if (this.#classes.has(className)) {
          try {
            const classDescription = this.#classes.get(className);
            const stateId = generateStateId();
            const instanceId = instanceIdGenerator();

            // apply create hooks on init values
            const hooks = this.#createHooksByClassName.get(className);
            let hookAborted = false;

            for (let hook of hooks.values()) {
              const result = await hook(initValues);

              if (result === null) { // explicit abort
                hookAborted = true;
                break;
              } else if (result === undefined) { // implicit continue
                continue;
              } else {
                initValues = result;
              }
            }

            if (hookAborted) {
              throw new Error(`A 'serverStateManagerCreateHook' explicitly aborted state creation of class '${className}' by returning 'null'`);
            }

            const state = new SharedStatePrivate(this, className, classDescription, stateId, initValues);
            // attach client to the state as owner
            const isOwner = true;
            const filter = null;
            state[kSharedStatePrivateAttachClient](instanceId, client, isOwner, filter);

            this.#sharedStatePrivateById.set(stateId, state);

            const currentValues = state.parameters.getValues();
            const classDescriptionOption = requireDescription ? classDescription : null;

            client.transport.emit(
              CREATE_RESPONSE,
              reqId,
              stateId,
              instanceId,
              className,
              classDescriptionOption,
              currentValues,
            );

            const isObservable = this.#isObservableState(state);

            if (isObservable) {
              this.#observers.forEach(observer => {
                observer.transport.emit(OBSERVE_NOTIFICATION, className, stateId, nodeId);
              });
            }
          } catch (err) {
            const msg = `${err.message}`;
            client.transport.emit(CREATE_ERROR, reqId, msg);
          }
        } else {
          const msg = `Undefined SharedStateClassName '${className}'`;
          client.transport.emit(CREATE_ERROR, reqId, msg);
        }
      },
    );

    // ---------------------------------------------
    // ATTACH (when creator, is attached by default)
    // ---------------------------------------------
    client.transport.addListener(
      ATTACH_REQUEST,
      (reqId, className, stateId = null, requireDescription = true, filter = null) => {
        if (this.#classes.has(className)) {
          let state = null;

          if (stateId !== null &amp;&amp; this.#sharedStatePrivateById.has(stateId)) {
            state = this.#sharedStatePrivateById.get(stateId);
          } else if (stateId === null) {
            // if no `stateId` given, we try to find the first state with the given
            // `className` in the list, this allow a client to attach to a global
            // state created by the server (or some persistent client) without
            // having to know the `stateId` (e.g. some global state...)
            for (let existingState of this.#sharedStatePrivateById.values()) {
              if (existingState.className === className) {
                state = existingState;
                break;
              }
            }
          }

          if (state !== null) {
            // @note - we use a unique remote id to allow a client to attach
            // several times to the same state.
            // i.e. same state -> several remote attach on the same node
            const instanceId = instanceIdGenerator();
            const isOwner = false;
            const currentValues = state.parameters.getValues();
            const classDescription = this.#classes.get(className);
            const classDescriptionOption = requireDescription ? classDescription : null;

            // if filter given, check that all filter entries are valid class keys
            // @todo - improve error reporting: report invalid filters
            if (filter !== null) {
              const keys = Object.keys(classDescription);
              const isValid = filter.reduce((acc, key) => acc &amp;&amp; keys.includes(key), true);

              if (!isValid) {
                const msg = `Invalid filter (${filter.join(', ')}) for class '${className}'`;
                return client.transport.emit(ATTACH_ERROR, reqId, msg);
              }
            }

            state[kSharedStatePrivateAttachClient](instanceId, client, isOwner, filter);

            client.transport.emit(
              ATTACH_RESPONSE,
              reqId,
              state.id,
              instanceId,
              className,
              classDescriptionOption,
              currentValues,
              filter,
            );

          } else {
            const msg = `No existing state for class "${className}" with stateId: "${stateId}"`;
            client.transport.emit(ATTACH_ERROR, reqId, msg);
          }
        } else {
          const msg = `Undefined SharedStateClassName '${className}'`;
          client.transport.emit(ATTACH_ERROR, reqId, msg);
        }
      },
    );

    // ---------------------------------------------
    // OBSERVE PEERS (be notified when a state is created, lazy)
    // ---------------------------------------------
    client.transport.addListener(OBSERVE_REQUEST, (reqId, observedClassName) => {
      if (observedClassName === null || this.#classes.has(observedClassName)) {
        const list = [];

        this.#sharedStatePrivateById.forEach(state => {
          const isObservable = this.#isObservableState(state);

          if (isObservable) {
            const { className, id, creatorId } = state;
            list.push([className, id, creatorId]);
          }
        });

        // add client to observers first because if some synchronous server side
        // callback throws, the client would never be added to the list
        this.#observers.add(client);

        client.transport.emit(OBSERVE_RESPONSE, reqId, ...list);
      } else {
        const msg = `Undefined SharedStateClassName '${observedClassName}'`;
        client.transport.emit(OBSERVE_ERROR, reqId, msg);
      }
    });

    client.transport.addListener(UNOBSERVE_NOTIFICATION, () => {
      this.#observers.delete(client);
    });

    // ---------------------------------------------
    // GET CLASS DESCRIPTION
    // ---------------------------------------------
    client.transport.addListener(GET_CLASS_DESCRIPTION_REQUEST, (reqId, className) => {
      if (this.#classes.has(className)) {
        const classDescription = this.#classes.get(className);
        client.transport.emit(
          GET_CLASS_DESCRIPTION_RESPONSE,
          reqId,
          className,
          classDescription,
        );
      } else {
        const msg = `Undefined SharedStateClassName '${className}'`;
        client.transport.emit(GET_CLASS_DESCRIPTION_ERROR, reqId, msg);
      }
    });
  }

  /**
   * Remove a client from the manager. Clean all created or attached states.
   *
   * This is automatically handled by the {@link Server} when a client disconnects.
   *
   * @param {number} nodeId - Id of the client node, as given in
   *  {@link client.StateManager}
   *
   * @private
   */
  [kServerStateManagerRemoveClient](nodeId) {
    for (let [_id, state] of this.#sharedStatePrivateById.entries()) {
      let deleteState = false;

      // define if the client is the creator of the state, in which case
      // everybody must delete it
      for (let [instanceId, clientInfos] of state.attachedClients) {
        const attachedClient = clientInfos.client;

        if (nodeId === attachedClient.id &amp;&amp; instanceId === state.creatorInstanceId) {
          deleteState = true;
        }
      }

      for (let [instanceId, clientInfos] of state.attachedClients) {
        const attachedClient = clientInfos.client;

        if (nodeId === attachedClient.id) {
          state[kSharedStatePrivateDetachClient](instanceId, attachedClient);
        }

        if (deleteState) {
          if (instanceId !== state.creatorInstanceId) {
            // send notification to other attached nodes
            attachedClient.transport.emit(`${DELETE_NOTIFICATION}-${state.id}-${instanceId}`);
          }

          this[kServerStateManagerDeletePrivateState](state);
        }
      }
    }

    // if is an observer, delete it
    const client = this[kStateManagerClientsByNodeId].get(nodeId);
    this.#observers.delete(client);
    this[kStateManagerClientsByNodeId].delete(nodeId);
  }

  #isObservableState(state) {
    // is observable if not in private states list
    return !PRIVATE_STATES.includes(state.className);
  }

  /**
   * Define a generic class from which {@link SharedState}s can be created.
   *
   * @param {SharedStateClassName} className - Name of the class.
   * @param {SharedStateClassDescription} classDescription - Description of the class.
   *
   * @see {@link ServerStateManager#create}
   * @see {@link ClientStateManager#create}
   *
   * @example
   * server.stateManager.defineClass('my-class', {
   *   myBoolean: {
   *     type: 'boolean'
   *     default: false,
   *   },
   *   myFloat: {
   *     type: 'float'
   *     default: 0.1,
   *     min: -1,
   *     max: 1
   *   }
   * });
   */
  defineClass(className, classDescription) {
    if (!isString(className)) {
      throw new TypeError(`Cannot execute 'defineClass' (${className}) on ServerStateManager: argument 1 must be of type SharedStateClassName`);
    }

    if (!isPlainObject(classDescription)) {
      throw new TypeError(`Cannot execute 'defineClass' (${className}) on ServerStateManager: argument 2 must be of type SharedStateClassDescription`);
    }

    if (this.#classes.has(className)) {
      throw new DOMException(`Cannot execute 'defineClass'(${className})  on ServerStateManager: SharedState class '${className}' is already defined`, 'NotSupportedError');
    }

    try {
      ParameterBag.validateDescription(classDescription);
    } catch (err) {
      throw new TypeError(`Cannot execute 'defineClass' (${className}) on ServerStateManager: ${err.message}`);
    }

    this.#classes.set(className, clonedeep(classDescription));
    // create hooks list
    this.#createHooksByClassName.set(className, new Set());
    this.#updateHooksByClassName.set(className, new Set());
    this.#deleteHooksByClassName.set(className, new Set());
  }

  /**
   * @deprecated Use {@link ServerStateManager#defineClass} instead.
   */
  registerSchema(className, classDescription) {
    logger.deprecated('ServerStateManager#registerSchema', 'ServerStateManager#defineClass', '4.0.0-alpha.29');
    this.defineClass(className, classDescription);
  }

  /**
   * Delete a whole class of {@link SharedState}.
   *
   * All {@link SharedState} instances created from this class will be deleted
   * as well, triggering their eventual `onDetach` and `onDelete` callbacks.
   *
   * @param {SharedStateClassName} className - Name of the shared state class to delete.
   */
  deleteClass(className) {
    // @note: deleting schema
    for (let [_, state] of this.#sharedStatePrivateById) {
      if (state.className === className) {
        for (let [instanceId, clientInfos] of state.attachedClients) {
          const attached = clientInfos.client;
          state[kSharedStatePrivateDetachClient](instanceId, attached);
          attached.transport.emit(`${DELETE_NOTIFICATION}-${state.id}-${instanceId}`);
        }

        this[kServerStateManagerDeletePrivateState](state);
      }
    }

    // clear class cache of all connected clients
    for (let client of this[kStateManagerClientsByNodeId].values()) {
      client.transport.emit(`${DELETE_SHARED_STATE_CLASS}`, className);
    }

    this.#classes.delete(className);
    // delete registered hooks
    this.#createHooksByClassName.delete(className);
    this.#updateHooksByClassName.delete(className);
    this.#deleteHooksByClassName.delete(className);
  }

  /**
   * @deprecated Use {@link ServerStateManager#defineClass} instead.
   */
  deleteSchema(className) {
    logger.deprecated('ServerStateManager#deleteSchema', 'ServerStateManager#deleteClass', '4.0.0-alpha.29');
    this.deleteClass(className);
  }

  /**
   * Register a function for a given class of shared state class to be executed
   * when a state is created.
   *
   * For example, this can be useful to retrieve some initialization values stored
   * in the filesystem, given the value (e.g. a hostname) of one the parameters.
   *
   * The hook is associated to each states created from the given class name.
   * Note that the hooks are executed server-side regardless the node on which
   * `create` has been called.
   *
   * Multiple hook can be added to the same `className`, they will be executed in
   * order of registration.
   *
   * @param {string} className - Kind of states on which applying the hook.
   * @param {serverStateManagerUpdateHook} createHook - Function called on when
   *  a state of `className` is created on the network.
   *
   * @returns {function} deleteHook - Handler that deletes the hook when executed.
   *
   * @example
   * server.stateManager.defineClass('hooked', {
   *   name: { type: 'string', required: true },
   *   hookTriggered: { type: 'boolean', default: false },
   * });
   * server.stateManager.registerCreateHook('hooked', initValues => {
   *   return {
   *     ...initValues
   *     hookTriggered: true,
   *   };
   * });
   *
   * const state = await server.stateManager.create('hooked', {
   *   name: 'coucou',
   * });
   *
   * const values = state.getValues();
   * assert.deepEqual(result, { value: 'coucou', hookTriggered: true });
   */
  registerCreateHook(className, createHook) {
    if (!this.#classes.has(className)) {
      throw new TypeError(`Cannot execute 'registerCreateHook' (${className}) on BaseStateManager: SharedState class '${className}' is not defined`);
    }

    if (!isFunction(createHook)) {
      throw new TypeError(`Cannot execute 'registerCreateHook' (${className}) on BaseStateManager: argument 2 must be a function`);
    }

    const hooks = this.#createHooksByClassName.get(className);
    hooks.add(createHook);

    return () => hooks.delete(createHook);
  }

  /**
   * Register a function for a given class of shared state class to be executed
   * when a state is deleted.
   *
   * For example, this can be useful to store the values of a given shared state
   * in the filesystem.
   *
   * The hook is associated to each states created from the given class name.
   * Note that the hooks are executed server-side regardless the node on which
   * `delete` has been called.
   *
   * Multiple hook can be added to the same `className`, they will be executed in
   * order of registration.
   *
   * @param {string} className - Kind of states on which applying the hook.
   * @param {serverStateManagerUpdateHook} createHook - Function called on when
   *  a state of `className` is created on the network.
   *
   * @returns {function} deleteHook - Handler that deletes the hook when executed.
   *
   * @example
   * server.stateManager.defineClass('hooked', {
   *   name: { type: 'string', required: true },
   *   hookTriggered: { type: 'boolean', default: false },
   * });
   * server.stateManager.registerDeleteHook('hooked', async currentValues => {
   *   await doSomethingWithValues(currentValues)
   * });
   *
   * const state = await server.stateManager.create('hooked');
   * // later
   * await state.delete();
   */
  registerDeleteHook(className, deleteHook) {
    if (!this.#classes.has(className)) {
      throw new TypeError(`Cannot execute 'registerDeleteHook' (${className}) on BaseStateManager: SharedState class '${className}' is not defined`);
    }

    if (!isFunction(deleteHook)) {
      throw new TypeError(`Cannot execute 'registerDeleteHook' (${className}) on BaseStateManager: argument 2 must be a function`);
    }

    const hooks = this.#deleteHooksByClassName.get(className);
    hooks.add(deleteHook);

    return () => hooks.delete(deleteHook);
  }

  /**
   * Register a function for a given class of shared state to be executed between
   * `set` instructions and `onUpdate` callback(s).
   *
   * For example, this can be used to implement a preset system where all the values
   * of the state are updated from e.g. some data stored in filesystem while the
   * consumer of the state only want to update the preset name.
   *
   * The hook is associated to each states created from the given class name and
   * executed on each update (i.e. `state.set(updates)`). Note that the hooks are
   * executed server-side regardless the node on which `set` has been called and
   * before the call of the `onUpdate` callback of the shared state.
   *
   * Multiple hook can be added to the same `className`, they will be executed in
   * order of registration.
   *
   * @param {string} className - Kind of states on which applying the hook.
   * @param {serverStateManagerUpdateHook} updateHook - Function called on each update,
   *  to eventually modify the updates before they are actually applied.
   *
   * @returns {function} deleteHook - Handler that deletes the hook when executed.
   *
   * @example
   * server.stateManager.defineClass('hooked', {
   *   value: { type: 'string', default: null, nullable: true },
   *   numUpdates: { type: 'integer', default: 0 },
   * });
   * server.stateManager.registerUpdateHook('hooked', updates => {
   *   return {
   *     ...updates
   *     numUpdates: currentValues.numUpdates + 1,
   *   };
   * });
   *
   * const state = await server.stateManager.create('hooked');
   *
   * await state.set({ value: 'test' });
   * const values = state.getValues();
   * assert.deepEqual(result, { value: 'test', numUpdates: 1 });
   */
  registerUpdateHook(className, updateHook) {
    if (!this.#classes.has(className)) {
      throw new TypeError(`Cannot execute 'registerUpdateHook' (${className}) on BaseStateManager: SharedState class '${className}' is not defined`);
    }

    if (!isFunction(updateHook)) {
      throw new TypeError(`Cannot execute 'registerUpdateHook' (${className}) on BaseStateManager: argument 2 must be a function`);
    }

    const hooks = this.#updateHooksByClassName.get(className);
    hooks.add(updateHook);

    return () => hooks.delete(updateHook);
  }
}

export default ServerStateManager;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Fri Mar 28 2025 11:04:02 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



    <link type="text/css" rel="stylesheet" href="assets/custom.css">
    
</body>
</html>
