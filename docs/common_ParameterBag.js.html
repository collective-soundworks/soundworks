<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>common/ParameterBag.js - soundworks</title>
    
    <meta name="description" content="Documentation of soundworks, a full-stack JavaScript framework for distributed WebAudio and multimedia applications" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="http://collective-soundworks.github.io/" target="_blank" class="menu-item" id="website_link" >Resources</a></h2><h2><a href="https://github.com/collective-soundworks/soundworks" target="_blank" class="menu-item" id="website_link" >Github</a></h2><h3>Namespaces</h3><ul><li><a href="client.html">client</a></li><li><a href="server.html">server</a></li></ul><h3>Classes</h3><ul><li><a href="client.AbstractExperience.html">client.AbstractExperience</a><ul class='methods'><li data-type='method'><a href="client.AbstractExperience.html#require">require</a></li><li data-type='method'><a href="client.AbstractExperience.html#start">start</a></li></ul></li><li><a href="client.AbstractPlugin.html">client.AbstractPlugin</a><ul class='methods'><li data-type='method'><a href="client.AbstractPlugin.html#configure">configure</a></li><li data-type='method'><a href="client.AbstractPlugin.html#ready">ready</a></li><li data-type='method'><a href="client.AbstractPlugin.html#start">start</a></li><li data-type='method'><a href="client.AbstractPlugin.html#started">started</a></li></ul></li><li><a href="client.Client.html">client.Client</a><ul class='methods'><li data-type='method'><a href="client.Client.html#init">init</a></li><li data-type='method'><a href="client.Client.html#start">start</a></li></ul></li><li><a href="client.PluginManager.html">client.PluginManager</a><ul class='methods'><li data-type='method'><a href="client.PluginManager.html#get">get</a></li><li data-type='method'><a href="client.PluginManager.html#register">register</a></li></ul></li><li><a href="client.SharedStateManagerClient.html">client.SharedStateManagerClient</a><ul class='methods'><li data-type='method'><a href="client.SharedStateManagerClient.html#attach">attach</a></li><li data-type='method'><a href="client.SharedStateManagerClient.html#create">create</a></li><li data-type='method'><a href="client.SharedStateManagerClient.html#observe">observe</a></li></ul></li><li><a href="client.Socket.html">client.Socket</a><ul class='methods'><li data-type='method'><a href="client.Socket.html#addBinaryListener">addBinaryListener</a></li><li data-type='method'><a href="client.Socket.html#addListener">addListener</a></li><li data-type='method'><a href="client.Socket.html#removeAllBinaryListeners">removeAllBinaryListeners</a></li><li data-type='method'><a href="client.Socket.html#removeAllListeners">removeAllListeners</a></li><li data-type='method'><a href="client.Socket.html#removeBinaryListener">removeBinaryListener</a></li><li data-type='method'><a href="client.Socket.html#removeListener">removeListener</a></li><li data-type='method'><a href="client.Socket.html#send">send</a></li><li data-type='method'><a href="client.Socket.html#sendBinary">sendBinary</a></li></ul></li><li><a href="common.SharedState.html">common.SharedState</a><ul class='methods'><li data-type='method'><a href="common.SharedState.html#delete">delete</a></li><li data-type='method'><a href="common.SharedState.html#detach">detach</a></li><li data-type='method'><a href="common.SharedState.html#get">get</a></li><li data-type='method'><a href="common.SharedState.html#getDefaults">getDefaults</a></li><li data-type='method'><a href="common.SharedState.html#getInitValues">getInitValues</a></li><li data-type='method'><a href="common.SharedState.html#getSchema">getSchema</a></li><li data-type='method'><a href="common.SharedState.html#getValues">getValues</a></li><li data-type='method'><a href="common.SharedState.html#onDelete">onDelete</a></li><li data-type='method'><a href="common.SharedState.html#onDetach">onDetach</a></li><li data-type='method'><a href="common.SharedState.html#set">set</a></li><li data-type='method'><a href="common.SharedState.html#subscribe">subscribe</a></li></ul></li><li><a href="server.AbstractExperience.html">server.AbstractExperience</a><ul class='methods'><li data-type='method'><a href="server.AbstractExperience.html#enter">enter</a></li><li data-type='method'><a href="server.AbstractExperience.html#require">require</a></li></ul></li><li><a href="server.AbstractPlugin.html">server.AbstractPlugin</a><ul class='methods'><li data-type='method'><a href="server.AbstractPlugin.html#configure">configure</a></li><li data-type='method'><a href="server.AbstractPlugin.html#connect">connect</a></li><li data-type='method'><a href="server.AbstractPlugin.html#disconnect">disconnect</a></li><li data-type='method'><a href="server.AbstractPlugin.html#ready">ready</a></li><li data-type='method'><a href="server.AbstractPlugin.html#start">start</a></li><li data-type='method'><a href="server.AbstractPlugin.html#started">started</a></li></ul></li><li><a href="server.Client.html">server.Client</a></li><li><a href="server.PluginManager.html">server.PluginManager</a><ul class='methods'><li data-type='method'><a href="server.PluginManager.html#get">get</a></li><li data-type='method'><a href="server.PluginManager.html#register">register</a></li></ul></li><li><a href="server.Server.html">server.Server</a><ul class='methods'><li data-type='method'><a href="server.Server.html#init">init</a></li><li data-type='method'><a href="server.Server.html#start">start</a></li></ul></li><li><a href="server.SharedStateManagerServer.html">server.SharedStateManagerServer</a><ul class='methods'><li data-type='method'><a href="server.SharedStateManagerServer.html#attach">attach</a></li><li data-type='method'><a href="server.SharedStateManagerServer.html#create">create</a></li><li data-type='method'><a href="server.SharedStateManagerServer.html#deleteSchema">deleteSchema</a></li><li data-type='method'><a href="server.SharedStateManagerServer.html#observe">observe</a></li><li data-type='method'><a href="server.SharedStateManagerServer.html#registerSchema">registerSchema</a></li><li data-type='method'><a href="server.SharedStateManagerServer.html#registerUpdateHook">registerUpdateHook</a></li></ul></li><li><a href="server.Socket.html">server.Socket</a><ul class='methods'><li data-type='method'><a href="server.Socket.html#addBinaryListener">addBinaryListener</a></li><li data-type='method'><a href="server.Socket.html#addListener">addListener</a></li><li data-type='method'><a href="server.Socket.html#addToRoom">addToRoom</a></li><li data-type='method'><a href="server.Socket.html#removeAllBinaryListeners">removeAllBinaryListeners</a></li><li data-type='method'><a href="server.Socket.html#removeAllListeners">removeAllListeners</a></li><li data-type='method'><a href="server.Socket.html#removeBinaryListener">removeBinaryListener</a></li><li data-type='method'><a href="server.Socket.html#removeFromRoom">removeFromRoom</a></li><li data-type='method'><a href="server.Socket.html#removeListener">removeListener</a></li><li data-type='method'><a href="server.Socket.html#send">send</a></li><li data-type='method'><a href="server.Socket.html#sendBinary">sendBinary</a></li></ul></li><li><a href="server.Sockets.html">server.Sockets</a><ul class='methods'><li data-type='method'><a href="server.Sockets.html#addToRoom">addToRoom</a></li><li data-type='method'><a href="server.Sockets.html#broadcast">broadcast</a></li><li data-type='method'><a href="server.Sockets.html#broadcastBinary">broadcastBinary</a></li><li data-type='method'><a href="server.Sockets.html#removeFromRoom">removeFromRoom</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">common/ParameterBag.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// import types from './types';
import cloneDeep from 'lodash.cloneDeep';
import equal from 'fast-deep-equal';


/**
 * @typedef {Object} server.SharedStateManagerServer~schema
 *
 * Description of a schema to be register by the {@link server.ServerStateManagerServer}
 * A schema consists of a combinaison of key value pairs where the key is the
 * name of the parameter, and the value is an object describing the parameter.
 *
 * Available types are:
 * - {@link server.SharedStateManagerServer~schemaBooleanDef}
 * - {@link server.SharedStateManagerServer~schemaStringDef}
 * - {@link server.SharedStateManagerServer~schemaIntegerDef}
 * - {@link server.SharedStateManagerServer~schemaFloatDef}
 * - {@link server.SharedStateManagerServer~schemaEnumDef}
 * - {@link server.SharedStateManagerServer~schemaAnyDef}
 *
 * @example
 * {
 *   myBoolean: {
 *     type: 'boolean'
 *     default: false,
 *   },
 *   myFloat: {
 *     type: 'float'
 *     default: 0.1,
 *     min: -1,
 *     max: 1,
 *     event: true,
 *   }
 * }
 */
/**
 * @typedef {Object} server.SharedStateManagerServer~schemaBooleanDef
 *
 * @property {String} type='boolean' - Define a boolean parameter.
 * @property {Boolean} default - Default value of the parameter.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */
/**
 * @typedef {Object} server.SharedStateManagerServer~schemaStringDef
 *
 * @property {String} type='string' - Define a boolean parameter.
 * @property {Mixed} default - Default value of the parameter.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */
/**
 @typedef {Object} server.SharedStateManagerServer~schemaIntegerDef
 *
 * @property {String} type='integer' - Define a boolean parameter.
 * @property {Mixed} default - Default value of the parameter.
 * @property {Number} [min=-Infinity] - Minimum value of the parameter.
 * @property {Number} [max=+Infinity] - Maximum value of the parameter.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */
/**
 * @typedef {Object} server.SharedStateManagerServer~schemaFloatDef
 *
 * @property {String} [type='float'] - Float parameter.
 * @property {Mixed} default - Default value.
 * @property {Number} [min=-Infinity] - Minimum value.
 * @property {Number} [max=+Infinity] - Maximum value.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */
/**
 * @typedef {Object} server.SharedStateManagerServer~schemaEnumDef
 *
 * @property {String} [type='enum'] - Enum parameter.
 * @property {Mixed} default - Default value of the parameter.
 * @property {Array} list - Possible values of the parameter.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */
/**
 * @typedef {Object} server.SharedStateManagerServer~schemaAnyDef
 *
 * @property {String} [type='any'] - Parameter of any type.
 * @property {Mixed} default - Default value of the parameter.
 * @property {Boolean} [nullable=false] - Define if the parameter is nullable. If
 *   set to `true` the parameter `default` is set to `null`.
 * @property {Boolean} [event=false] - Define if the parameter is a volatile, e.g.
 *   set its value back to `null` after propagation. When `true`, `nullable` is
 *   automatically set to `true` and `default` to `null`.
 * @property {Boolean} [filterChange=true] - Setting this option to `false` forces
 *   the propagation of a parameter even when its value do not change. It
 *   offers a kind of middle ground between the default bahavior (e.g. where
 *   only changed values are propagated) and the behavior of the `event` option
 *   (which has no state per se). As such, setting this options to `false` if
 *   `event=true` does not make sens.
 * @property {Boolean} [immediate=false] - Setting this option to `true` will
 *   trigger any change (e.g. call the subscribe listeners) immediately on the
 *   state that generate the update (i.e. calling `set`), before propagating the
 *   change on the network. This option can be usefull in cases the network
 *   would introduce a noticeable latency on the client. If for some reason
 *   the value is overriden server-side (e.g. in an updateHook) the listeners
 *   will be called again on when the "real" / final value will be received.
 * @property {Object} [metas={}] - Optionnal metadata of the parameter.
 */

export const sharedOptions = {
  nullable: false,
  event: false, // if event=true, nullable=true
  metas: {},
  filterChange: true,
  // immediate: false,
}

export const types = {
  boolean: {
    required: ['default'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {});
    },
    coerceFunction: (name, def, value) => {
      if (typeof value !== 'boolean') {
        throw new TypeError(`[stateManager] Invalid value for boolean param "${name}": ${value}`);
      }

      return value;
    }
  },
  string: {
    required: ['default'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {});
    },
    coerceFunction: (name, def, value) => {
      if (typeof value !== 'string') {
        throw new TypeError(`[stateManager] Invalid value for string param "${name}": ${value}`);
      }

      return value;
    }
  },
  integer: {
    required: ['default'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {
        min: -Infinity,
        max: +Infinity,
      });
    },
    coerceFunction: (name, def, value) => {
      if (!(typeof value === 'number' &amp;&amp; Math.floor(value) === value)) {
        throw new TypeError(`[stateManager] Invalid value for integer param "${name}": ${value}`);
      }

      return Math.max(def.min, Math.min(def.max, value));
    }
  },
  float: {
    required: ['default'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {
        min: -Infinity,
        max: +Infinity,
      });
    },
    coerceFunction: (name, def, value) => {
      if (typeof value !== 'number' || value !== value) { // reject NaN
        throw new TypeError(`[stateManager] Invalid value for float param "${name}": ${value}`);
      }

      return Math.max(def.min, Math.min(def.max, value));
    }
  },
  enum: {
    required: ['default', 'list'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {});
    },
    coerceFunction: (name, def, value) => {
      if (def.list.indexOf(value) === -1) {
        throw new TypeError(`[stateManager] Invalid value for enum param "${name}": ${value}`);
      }


      return value;
    }
  },
  any: {
    required: ['default'],
    get defaultOptions() {
      return Object.assign(cloneDeep(sharedOptions), {});
    },
    coerceFunction: (name, def, value) => {
      // no check as it can have any type...
      return value;
    }
  }
}


/**
 * Bag of parameters.
 * @private
 */
class ParameterBag {
  static validateSchema(schema) {
    for (let name in schema) {
      const def = schema[name];

      if (!def.hasOwnProperty('type')) {
        throw new TypeError(`[stateManager] Invalid schema definition - param "${name}": "type" key is required`);
      }

      if (!types.hasOwnProperty(def.type)) {
        throw new TypeError(`[stateManager] Invalid schema definition - param "${name}": "{ type: '${def.type}' }" does not exists`);
      }

      const required = types[def.type].required;

      required.forEach(function(key) {
        if (def.event === true &amp;&amp; key === 'default') {
          // do nothing, default is always null for `event` params
        } else if (!def.hasOwnProperty(key)) {
          throw new TypeError(`[stateManager] Invalid schema definition - param "${name}" (type "${def.type}"): "${key}" key is required`);
        }
      });
    }
  }

  constructor(schema, initValues = {}) {
    if (!schema) {
      throw new Error(`[stateManager] schema is mandatory`);
    }

    schema = cloneDeep(schema);
    initValues = cloneDeep(initValues);

    /**
     * List of parameters.
     *
     * @type {Object&lt;String, Param>}
     * @name _params
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._values = {};

    /**
     * List of schema with init values.
     *
     * @type {Object&lt;String, paramDefinition>}
     * @name _schema
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._schema = {};

    ParameterBag.validateSchema(schema);

    // make shure initValues make sens according to the given schema
    for (let name in initValues) {
      if (!schema.hasOwnProperty(name)) {
        throw new ReferenceError(`[stateManager] init value defined for undefined param "${name}"`);
      }
    }

    for (let [name, def] of Object.entries(schema)) {
      const {
        defaultOptions,
        coerceFunction
      } = types[def.type];

      def = Object.assign({}, defaultOptions, def);
      // if event property is set to true, the param must
      // be nullable and its default value is `undefined`
      if (def.event === true) {
        def.nullable = true;
        def.default = null;
      }

      let initValue;

      if (initValues.hasOwnProperty(name)) {
        initValue = initValues[name];
      } else {
        initValue = def.default;
      }


      this._schema[name] = def;
      // coerce init value and store in definition
      initValue = this.set(name, initValue)[0];

      this._schema[name].initValue = initValue;
      this._values[name] = initValue;

    }
  }

  /**
   * Define if the parameter exists.
   *
   * @param {String} name - Name of the parameter.
   * @return {Boolean}
   */
  has(name) {
    return this._schema.hasOwnProperty(name);
  }

  /**
   * Return values of all parameters as a flat object.
   *
   * @return {Object}
   */
  getValues() {
    return Object.assign({}, this._values);
  }

  /**
   * Return the value of the given parameter.
   *
   * @param {String} name - Name of the parameter.
   * @return {Mixed} - Value of the parameter.
   */
  get(name) {
    if (!this.has(name)) {
      throw new ReferenceError(`[stateManager] Cannot get value of undefined parameter "${name}"`);
    }

    return this._values[name];
  }

  /**
   * Set the value of a parameter. If the value of the parameter is updated
   * (aka if previous value is different from new value) all registered
   * callbacks are registered.
   *
   * @param {String} name - Name of the parameter.
   * @param {Mixed} value - Value of the parameter.
   * @param {Boolean} [forcePropagation=false] - if true, propagate value even
   *    if the value has not changed.
   * @return {Array} - [new value, updated flag].
   */
  set(name, value) {
    if (!this.has(name)) {
      throw new ReferenceError(`[stateManager] Cannot set value of undefined parameter "${name}"`);
    }

    const def = this._schema[name];
    const { coerceFunction } = types[def.type];

    if (value === null &amp;&amp; def.nullable === false) {
      throw new TypeError(`[stateManager] Invalid value for ${def.type} param "${name}": value is null and param is not nullable`);
    } else if (value === null &amp;&amp; def.nullable === true) {
      value = value;
    } else {
      value = coerceFunction(name, def, value);
    }

    const currentValue = this._values[name];
    const updated = !equal(currentValue, value);
    this._values[name] = value;

    if (def.event === true) {
      this._values[name] = null;
    }

    // return tuple so that the state manager can handle the `filterChange` option
    return [value, updated];
  }

  /**
   * Reset a parameter to its initialization values. Reset all parameters if no argument.
   *
   * @param {String} [name=null] - Name of the parameter to reset.
   */
  // reset(name = null) {
  //   if (name !== null) {
  //     this._params[name] = this._initValues[name];
  //   } else {
  //     for (let name in this.params) {
  //       this._params[name].reset();
  //     }
  //   }
  // }


  /**
   * Return the given schema along with the initialization values.
   *
   * @return {Object}
   */
  getSchema(name = null) {
    if (name === null) {
      return this._schema;
    } else {
      if (!this.has(name)) {
        throw new ReferenceError(`[stateManager] Cannot get schema description of undefined parameter "${name}"`);
      }

      return this._schema[name];
    }
  }

  // return the default value, if initValue has been given, return init values
  getInitValues() {
    const initValues = {};
    for (let [name, def] of Object.entries(this._schema)) {
      initValues[name] = def.initValue;
    }
    return initValues;
  }

    // return the default value, if initValue has been given, return init values
  getDefaults() {
    const defaults = {};
    for (let [name, def] of Object.entries(this._schema)) {
      defaults[name] = def.defaults;
    }
    return defaults;
  }
}

export default ParameterBag;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Sep 03 2021 16:02:33 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
